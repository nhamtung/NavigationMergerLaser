# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from sick_lidar_localization/SickLocResultPortTelegramMsg.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import sick_lidar_localization.msg
import std_msgs.msg

class SickLocResultPortTelegramMsg(genpy.Message):
  _md5sum = "4fe7bc3dfc1065d1a29951c990f7baf8"
  _type = "sick_lidar_localization/SickLocResultPortTelegramMsg"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """# Definition of ros message SickLocResultPortTelegramMsg.
# SickLocResultPortTelegramMsg publishes result port telegrams
# for sick localization. See chapter 5.9 ("About result port telegrams")
# of the operation manual for further details.

#
# Header
#

Header header                                 # ROS Header with sequence id, timestamp and frame id

#
# Result port telegram
#

SickLocResultPortHeaderMsg   telegram_header  # 52 byte header of a result port telegram
SickLocResultPortPayloadMsg  telegram_payload # 52 byte payload of a result port telegram
SickLocResultPortCrcMsg      telegram_trailer #  2 byte CRC trailer of a result port telegram

#
# System time of vehicles pose calculated by ros service "SickLocTimeSync" using a software pll
#

bool   vehicle_time_valid  # true: vehicle_time_sec and vehicle_time_nsec valid, false: software pll still in initial phase
uint32 vehicle_time_sec    # Time of vehicles pose calculated by software pll (seconds part of the system time)
uint32 vehicle_time_nsec   # Time of vehicles pose calculated by software pll (nano seconds part of the system time)

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: sick_lidar_localization/SickLocResultPortHeaderMsg
# Definition of ros message SickLocResultPortHeaderMsg.
# SickLocResultPortHeaderMsg publishes the header of a result port telegram
# for sick localization (52 byte). See chapter 5.9 ("About result port telegrams")
# of the operation manual for further details.

uint32  MagicWord        # Magic word SICK (0x53 0x49 0x43 0x4B). Size: 4 × UInt8 = 4 byte
uint32  Length           # Length of telegram incl. header, payload, and trailer. Size: UInt32 = 4 byte
uint16  PayloadType      # Payload type: 0x06c2 = Little Endian, 0x0642 = Big Endian. Size: UInt16 = 2 byte
uint16  PayloadVersion   # Version of PayloadType structure. Size: UInt16 = 2 byte
uint32  OrderNumber      # Order number of the localization controller. Size: UInt32 = 4 byte
uint32  SerialNumber     # Serial number of the localization controller. Size: UInt32 = 4 byte
uint8[] FW_Version       # Software version of the localization controller. Size: 20 × UInt8 = 20 byte
uint32  TelegramCounter  # Telegram counter since last start-up. Size: UInt32 = 4 byte
uint64  SystemTime       # Not used. Size: NTP = 8 byte


================================================================================
MSG: sick_lidar_localization/SickLocResultPortPayloadMsg
# Definition of ros message SickLocResultPortPayloadMsg.
# SickLocResultPortPayloadMsg publishes the payload of a result port telegram
# for sick localization (52 byte). See chapter 5.9 ("About result port telegrams")
# of the operation manual for further details.

uint16 ErrorCode      # ErrorCode 0: OK, ErrorCode 1: UNKNOWNERROR. Size: UInt16 = 2 byte
uint32 ScanCounter    # Counter of related scan data. Size: UInt32 = 4 byte
uint32 Timestamp      # Time stamp of the pose [ms]. The time stamp indicates the time at which the pose is calculated. Size: UInt32 = 4 byte
int32  PoseX          # Position X of the vehicle on the map in cartesian global coordinates [mm]. Size: Int32 = 4 byte
int32  PoseY          # Position Y of the vehicle on the map in cartesian global coordinates [mm]. Size: Int32 = 4 byte
int32  PoseYaw        # Orientation (yaw) of the vehicle on the map [mdeg] Size: Int32 = 4 byte
uint32 Reserved1      # Reserved. Size: UInt32 = 4 byte
int32  Reserved2      # Reserved. Size: Int32 = 4 byte
uint8  Quality        # Quality of pose [0 … 100], 1 = bad pose quality, 100 = good pose quality. Size: UInt8 = 1 byte
uint8  OutliersRatio  # Ratio of beams that cannot be assigned to the current reference map [%]. Size: UInt8 = 1 byte
int32  CovarianceX    # Covariance c1 of the pose X [mm^2]. Size: Int32 = 4 byte
int32  CovarianceY    # Covariance c5 of the pose Y [mm^2]. Size: Int32 = 4 byte
int32  CovarianceYaw  # Covariance c9 of the pose Yaw [mdeg^2]. Size: Int32 = 4 byte
uint64 Reserved3      # Reserved. Size: UInt64 = 8 byte


================================================================================
MSG: sick_lidar_localization/SickLocResultPortCrcMsg
# Definition of ros message SickLocResultPortCrcMsg.
# SickLocResultPortCrcMsg publishes the CRC trailer of a result port telegram
# for sick localization (2 byte). 
# Checksum details:
# * Width: 16 bits
# * Truncated polynomial: 0x1021 CRC polynomials with orders of x16 + x12 + x5 + 1 (counted without the leading '1' bit)
# * Initial value = 0xFFFF
# See chapter 5.9 ("About result port telegrams") of the operation manual for further details.

uint16 Checksum # CRC16-CCITT over length of header (52 bytes) and payload (52 bytes) without 2 bytes of this trailer. Size: UInt16 = 2 byte

"""
  __slots__ = ['header','telegram_header','telegram_payload','telegram_trailer','vehicle_time_valid','vehicle_time_sec','vehicle_time_nsec']
  _slot_types = ['std_msgs/Header','sick_lidar_localization/SickLocResultPortHeaderMsg','sick_lidar_localization/SickLocResultPortPayloadMsg','sick_lidar_localization/SickLocResultPortCrcMsg','bool','uint32','uint32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,telegram_header,telegram_payload,telegram_trailer,vehicle_time_valid,vehicle_time_sec,vehicle_time_nsec

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(SickLocResultPortTelegramMsg, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.telegram_header is None:
        self.telegram_header = sick_lidar_localization.msg.SickLocResultPortHeaderMsg()
      if self.telegram_payload is None:
        self.telegram_payload = sick_lidar_localization.msg.SickLocResultPortPayloadMsg()
      if self.telegram_trailer is None:
        self.telegram_trailer = sick_lidar_localization.msg.SickLocResultPortCrcMsg()
      if self.vehicle_time_valid is None:
        self.vehicle_time_valid = False
      if self.vehicle_time_sec is None:
        self.vehicle_time_sec = 0
      if self.vehicle_time_nsec is None:
        self.vehicle_time_nsec = 0
    else:
      self.header = std_msgs.msg.Header()
      self.telegram_header = sick_lidar_localization.msg.SickLocResultPortHeaderMsg()
      self.telegram_payload = sick_lidar_localization.msg.SickLocResultPortPayloadMsg()
      self.telegram_trailer = sick_lidar_localization.msg.SickLocResultPortCrcMsg()
      self.vehicle_time_valid = False
      self.vehicle_time_sec = 0
      self.vehicle_time_nsec = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2I2H2I().pack(_x.telegram_header.MagicWord, _x.telegram_header.Length, _x.telegram_header.PayloadType, _x.telegram_header.PayloadVersion, _x.telegram_header.OrderNumber, _x.telegram_header.SerialNumber))
      _x = self.telegram_header.FW_Version
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
      else:
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_IQH2I3iIi2B3iQHB2I().pack(_x.telegram_header.TelegramCounter, _x.telegram_header.SystemTime, _x.telegram_payload.ErrorCode, _x.telegram_payload.ScanCounter, _x.telegram_payload.Timestamp, _x.telegram_payload.PoseX, _x.telegram_payload.PoseY, _x.telegram_payload.PoseYaw, _x.telegram_payload.Reserved1, _x.telegram_payload.Reserved2, _x.telegram_payload.Quality, _x.telegram_payload.OutliersRatio, _x.telegram_payload.CovarianceX, _x.telegram_payload.CovarianceY, _x.telegram_payload.CovarianceYaw, _x.telegram_payload.Reserved3, _x.telegram_trailer.Checksum, _x.vehicle_time_valid, _x.vehicle_time_sec, _x.vehicle_time_nsec))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.telegram_header is None:
        self.telegram_header = sick_lidar_localization.msg.SickLocResultPortHeaderMsg()
      if self.telegram_payload is None:
        self.telegram_payload = sick_lidar_localization.msg.SickLocResultPortPayloadMsg()
      if self.telegram_trailer is None:
        self.telegram_trailer = sick_lidar_localization.msg.SickLocResultPortCrcMsg()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 20
      (_x.telegram_header.MagicWord, _x.telegram_header.Length, _x.telegram_header.PayloadType, _x.telegram_header.PayloadVersion, _x.telegram_header.OrderNumber, _x.telegram_header.SerialNumber,) = _get_struct_2I2H2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.telegram_header.FW_Version = str[start:end]
      _x = self
      start = end
      end += 75
      (_x.telegram_header.TelegramCounter, _x.telegram_header.SystemTime, _x.telegram_payload.ErrorCode, _x.telegram_payload.ScanCounter, _x.telegram_payload.Timestamp, _x.telegram_payload.PoseX, _x.telegram_payload.PoseY, _x.telegram_payload.PoseYaw, _x.telegram_payload.Reserved1, _x.telegram_payload.Reserved2, _x.telegram_payload.Quality, _x.telegram_payload.OutliersRatio, _x.telegram_payload.CovarianceX, _x.telegram_payload.CovarianceY, _x.telegram_payload.CovarianceYaw, _x.telegram_payload.Reserved3, _x.telegram_trailer.Checksum, _x.vehicle_time_valid, _x.vehicle_time_sec, _x.vehicle_time_nsec,) = _get_struct_IQH2I3iIi2B3iQHB2I().unpack(str[start:end])
      self.vehicle_time_valid = bool(self.vehicle_time_valid)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2I2H2I().pack(_x.telegram_header.MagicWord, _x.telegram_header.Length, _x.telegram_header.PayloadType, _x.telegram_header.PayloadVersion, _x.telegram_header.OrderNumber, _x.telegram_header.SerialNumber))
      _x = self.telegram_header.FW_Version
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
      else:
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_IQH2I3iIi2B3iQHB2I().pack(_x.telegram_header.TelegramCounter, _x.telegram_header.SystemTime, _x.telegram_payload.ErrorCode, _x.telegram_payload.ScanCounter, _x.telegram_payload.Timestamp, _x.telegram_payload.PoseX, _x.telegram_payload.PoseY, _x.telegram_payload.PoseYaw, _x.telegram_payload.Reserved1, _x.telegram_payload.Reserved2, _x.telegram_payload.Quality, _x.telegram_payload.OutliersRatio, _x.telegram_payload.CovarianceX, _x.telegram_payload.CovarianceY, _x.telegram_payload.CovarianceYaw, _x.telegram_payload.Reserved3, _x.telegram_trailer.Checksum, _x.vehicle_time_valid, _x.vehicle_time_sec, _x.vehicle_time_nsec))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.telegram_header is None:
        self.telegram_header = sick_lidar_localization.msg.SickLocResultPortHeaderMsg()
      if self.telegram_payload is None:
        self.telegram_payload = sick_lidar_localization.msg.SickLocResultPortPayloadMsg()
      if self.telegram_trailer is None:
        self.telegram_trailer = sick_lidar_localization.msg.SickLocResultPortCrcMsg()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 20
      (_x.telegram_header.MagicWord, _x.telegram_header.Length, _x.telegram_header.PayloadType, _x.telegram_header.PayloadVersion, _x.telegram_header.OrderNumber, _x.telegram_header.SerialNumber,) = _get_struct_2I2H2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.telegram_header.FW_Version = str[start:end]
      _x = self
      start = end
      end += 75
      (_x.telegram_header.TelegramCounter, _x.telegram_header.SystemTime, _x.telegram_payload.ErrorCode, _x.telegram_payload.ScanCounter, _x.telegram_payload.Timestamp, _x.telegram_payload.PoseX, _x.telegram_payload.PoseY, _x.telegram_payload.PoseYaw, _x.telegram_payload.Reserved1, _x.telegram_payload.Reserved2, _x.telegram_payload.Quality, _x.telegram_payload.OutliersRatio, _x.telegram_payload.CovarianceX, _x.telegram_payload.CovarianceY, _x.telegram_payload.CovarianceYaw, _x.telegram_payload.Reserved3, _x.telegram_trailer.Checksum, _x.vehicle_time_valid, _x.vehicle_time_sec, _x.vehicle_time_nsec,) = _get_struct_IQH2I3iIi2B3iQHB2I().unpack(str[start:end])
      self.vehicle_time_valid = bool(self.vehicle_time_valid)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2I2H2I = None
def _get_struct_2I2H2I():
    global _struct_2I2H2I
    if _struct_2I2H2I is None:
        _struct_2I2H2I = struct.Struct("<2I2H2I")
    return _struct_2I2H2I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_IQH2I3iIi2B3iQHB2I = None
def _get_struct_IQH2I3iIi2B3iQHB2I():
    global _struct_IQH2I3iIi2B3iQHB2I
    if _struct_IQH2I3iIi2B3iQHB2I is None:
        _struct_IQH2I3iIi2B3iQHB2I = struct.Struct("<IQH2I3iIi2B3iQHB2I")
    return _struct_IQH2I3iIi2B3iQHB2I
